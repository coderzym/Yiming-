# 作用域

- 作用域规定了在何处以及如何查找变量的规则，如果查找变量是为了赋值，那么就会使用LHS查询；如果查找变量是为了获取值，那么就会使用RHS查询。
- 在非严格模式下，如果LHS没有成功查找到`存放变量的容器`，就会在全局作用域内创建一个同名变量；如果RHS没有成功查询到值，那么就会报一个ReferenceError
- JS遵循了最小封闭原则，所以内部的函数的优先级是最高的，它可以访问外层的任意函数作用域

# 修改作用域

## eval

在非严格模式下，我们可以通过eval传入JS代码修改作用域，比如：

```
    function foo(b) {
        console.log(b) // 1
    }
    var a = 2
    foo("var a = 1")
```

但是在严格模式下，就无法修改其他作用域

## with

会根据你传递的对象判断是赋值还是创建，如果属性值已经存在，那么就会赋值，如果不存在，那么就会在全局作用域下创建一个同名变量，因为没有用标识符申明变量

##  为什么不建议使用？

因为消耗性能。编译器会在编译代码的时候对代码进行优化，但碰到了eval或者with时，它不知道内部的代码是什么样的，所以不会在`作用域查找`上进行优化，而且很有可能所做的优化是无意义的

# 作用域链

当代码在环境中创建时，会创建变量对象的一个作用域链来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在的环境变量对象，如果是函数执行阶段，那么会将活跃对象AO作为作用域的第一个对象，第二个对象是上级函数的执行上下文AO。

在查找变量的时候，会先从当前上下文的变量对象中查找，如果没有查找到，就会从词法层面上的父级的执行上下文中查找，一直找到全局变量对象为止。由多个执行上下文的变量对象构成的链表就叫做作用域链

# 闭包

这个是由作用域衍生的问题，只要使用了回调函数，实际上就是在使用闭包！也可以理解为只要访问了自由变量的函数，那这个函数和自由变量(既不是函数形参，也不是函数内的局部变量)就会形成闭包，自然而然能够理解