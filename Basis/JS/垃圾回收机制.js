/* 首先介绍两种常见的垃圾回收机制：标记清除算法和引用计数算法。

1. 标记清除算法

标记活动的对象，当程序执行完毕后，清除没有标记的对象，它的缺点就是会导致内存空间不连续。所以当我们声明新的变量时，JS引擎需要找到能储存这个变量的内存空间，通常会有三种方式，

1. First-fit，立即返回大于等于size的内存块；
2. Best-fit，返回大于等于size的最小内存块；
3. Worst-fit，遍历整个空闲列表，返回最大的内存块，根据size的大小一分为二；

所以也会导致分配空间过慢的问题。不过后来出了标记整理算法(Mark-Compact)，不同的是在分配空间的时候会将活动的对象移动到内存一端，然后进行清除。

2. 引用计数算法

计算对象的引用次数，当为0的时候会清除这个对象。但如果对象之间循环引用的话，那么永远都得不到清除，因此这个算法有较大的问题。

说完这基础的两种，我们来谈谈V8对GC的优化，

1. 分代式垃圾回收

新生代和老生代。

2. 并行回收

开启多个线程，每个线程分担一部分的回收工作，让用户不会感受到卡顿。

具体的可以看看这个：https://juejin.cn/post/6981588276356317214#heading-12 */
